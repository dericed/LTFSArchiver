#!/bin/bash

#  PrestoPRIME  LTFSArchiver
#  Version: 1.0 Beta
#  Authors: L. Savio, L. Boch, R. Borgotallo
#
#  Copyritght (C) 2011-2012 RAI â€“ Radiotelevisione Italiana <cr_segreteria@rai.it>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
############################################################################################
#	sample:  ./restore_file /dev/st0 000003L5 c56ad884-50d2-4135-b5a2-dd8123d04560
#       $1 = device su cui e' montato LTFS
#	$2 = label
#       $3/@ = UUID
#########################
CFG_FILE=`dirname $0`/../conf/ltfsarchiver.conf
. $CFG_FILE
. $LTFSARCHIVER_HOME/sbin/common.sh
###############################
PARMSN=$#
PARMSS=( $@ )
MAIN_LOG_FILE=${PARMSS[0]}
#       ARRAY CON LE UUID
for ((UUID_I=1; UUID_I<$PARMSN; UUID_I++)); do
	LISTA_UUID=( "${LISTA_UUID[@]}" ${PARMSS[$UUID_I]} )
done
#       Leggo i dati comuni a tutte le uuid prendendoli dalla prima
COMMON_PARMS=( `$CMD_DB" select ltotape, device from requests where uuid='${LISTA_UUID[0]}';" | tr -d ' ' | tr '|' ' ' ` )
SOURCEFS=/mnt/ltfs`basename ${COMMON_PARMS[1]}`

#       CICLO....
WORKING_IDX=0
for ((WORKING_IDX=0; WORKING_IDX<${#LISTA_UUID[@]}; WORKING_IDX++)); do
	#       Lettura parametri
	WORKING_UUID=${LISTA_UUID[$WORKING_IDX]}
	UUID_DATA_SOURCE=`$CMD_DB"select sourcefile from requests where uuid='$WORKING_UUID'" | sed -e 's/^[ \t]*//'`
	UUID_DATA_TARGET=`$CMD_DB"select destfile from requests where uuid='$WORKING_UUID'" | sed -e 's/^[ \t]*//'`
	#UUID_DATA=( `$CMD_DB"select sourcefile,destfile from requests where uuid='$WORKING_UUID'" | tr -d ' ' | tr '|' ' '` )
	main_logger 4 'UUID_DATA: SOURCE='"$UUID_DATA_SOURCE"' - TARGET='"$UUID_DATA_TARGET"
	#	Controllo esistenza e tipologia oggetto sorgente
	SPATH=$SOURCEFS/`echo  "${UUID_DATA_SOURCE}" | sed -e 's/.*\://'`
	#	Esiste il file/path sorgente?
	if [ -d "$SPATH" ] || [ -f "$SPATH" ]; then
		[ -d "$SPATH" ] && itemtype="d"
		[ -f "$SPATH" ] && itemtype="f"
		#	Scrivo lo spazio su DB (mi servira' per determinare la percentuale di completamento in GetResult
		NEEDEDSPACE=`du -ksm "$SPATH" | awk '{ print $1 }'`
		NEEDEDBYTE=`du --apparent-size -ksb "$SPATH" | awk '{ print $1 }'`
		$CMD_DB" update requests set sourcesize=$NEEDEDSPACE, sourcebytes=$NEEDEDBYTE where uuid='$WORKING_UUID';" > /dev/null 2>&1
		#	C'e' abbastanza spazio per il restore?
		FREESPACE=`df -P -m \`dirname "${UUID_DATA_TARGET}"\` | tail -1 | awk '{ print $3 }'`
		if [ $FREESPACE -ge $NEEDEDSPACE ]; then
			#	Passo in running
			update_uuid_status $WORKING_UUID 50
			#	il source e' una dir o un file?
			case $itemtype in
				"d")	#	File: uso rsync
					main_logger 0 "Starting restore (rsync) for uuid=$WORKING_UUID"
					 #       Nel primo includo i file che rispettano i parametri di dimensione ed estensione dichiarati in cfg
			                main_logger 1 "Phase 1 rsync command: $CMD_RSYNC "$SPATH"/ $UUID_DATA_TARGET $( get_rsync_rules R)"
					main_logger 0 "Starting rsync for uuid=$WORKING_UUID - phase 1"
					$CMD_RSYNC "$SPATH"/ $UUID_DATA_TARGET $( get_rsync_rules ) >> $MAIN_LOG_FILE
					STEP1_RC=$?
					if [ $STEP1_RC == 0 ]; then
						main_logger 1 "Rsync 1st step OK"
				                main_logger 1 "Phase 2 rsync command: $CMD_RSYNC "$SPATH"/ $UUID_DATA_TARGET"
						main_logger 0 "Starting rsync for uuid=$WORKING_UUID - phase 2"
						$CMD_RSYNC "$SPATH"/ $UUID_DATA_TARGET >> $MAIN_LOG_FILE
						STEP2_RC=$?
						if [ $STEP1_RC == 0 ]; then
							main_logger 1 "Rsync 2nd step OK"
						else
							main_logger 0 "Rsync 2nd step error: $STEP1_RC"
						fi
					else
						main_logger 0 "Rsync 1st step error: $STEP1_RC"
					fi
					COPY_RC=`echo "$STEP1_RC + $STEP2_RC" | bc`
				;;
				"f")	#	File: uso cp
					main_logger 0 "Starting restore (copy) for uuid=$WORKING_UUID"
					cp -p "$SPATH" "$UUID_DATA_TARGET"
					RRC=$?
					if [ $RRC == 0 ]; then
						main_logger 1 "File copy OK"
					else
						main_logger 0 "File copy error: $RRC"
					fi
					COPY_RC=$RRC
					sleep 10
				;;
			esac

			#       Com'e' andata?
			if [ $COPY_RC == 0 ]; then
				main_logger 0 "$WORKING_UUID restore complete"
				update_uuid_status $WORKING_UUID 60
			else
				main_logger 0 "$WORKING_UUID is now in fallout"
				fallout_uuid $WORKING_UUID 206
			fi
		else
			#	vado in fallout
			main_logger 0 "Needed space for restore: $NEEDEDSPACE MB - Free space found: $FREESPACE: $WORKING_UUID is now in fallout"
			fallout_uuid  $WORKING_UUID 205
		fi
	else
		#	vado in fallout
		main_logger 0 "flocat: $SPATH was not found: $WORKING_UUID is now in fallout"
		fallout_uuid  $WORKING_UUID 204
	fi
done
#       smonto il FS
umount $SOURCEFS
